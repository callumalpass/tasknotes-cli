#!/bin/bash

# TaskNotes FZF Interactive Browser
# Browse tasks with fuzzy search, preview, and quick actions

set -euo pipefail

# Configuration
DEFAULT_LIMIT=1000
FZF_HEIGHT="80%"
PREVIEW_WIDTH="50%"

# Colors and icons are handled inline in functions for better compatibility

# Help text
show_help() {
    cat << 'EOF'
TaskNotes FZF Interactive Browser

Usage: tn-fzf [OPTIONS] [FILTER]

Options:
  --help              Show this help
  --completed         Show completed tasks
  --overdue           Show overdue tasks  
  --today             Show today's tasks
  --active-timers     Show only tasks with active timers
  --project <name>    Filter by project
  --tag <name>        Filter by tag
  --status <status>   Filter by status
  --priority <level>  Filter by priority
  --limit <N>         Limit results (default: 1000)
  --no-preview        Disable file preview
  
Filter Examples:
  tn-fzf "priority:urgent"
  tn-fzf "tags:project AND status:in-progress"
  tn-fzf --today

Keybindings:
  ENTER               Open in Obsidian
  Ctrl-E              Open in $EDITOR
  Alt-A               Add new task (interactive)
  Alt-C               Complete/toggle task
  Alt-D               Delete task
  Alt-U               Update task properties
  Alt-T               Start timer for task
  Alt-S               Stop timer for task
  Alt-P               Start pomodoro for task
  Alt-I               Show task details/stats
  Ctrl-R              Refresh tasks
  Ctrl-T              Show timer status
  Ctrl-P              Show pomodoro status
  Ctrl-C / ESC        Exit
  
Requirements:
  - fzf
  - jq
  - TaskNotes CLI (tn)
EOF
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    command -v fzf >/dev/null || missing+=("fzf")
    command -v jq >/dev/null || missing+=("jq") 
    command -v tn >/dev/null || missing+=("tn")
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Error: Missing required dependencies:" >&2
        printf '  %s\n' "${missing[@]}" >&2
        echo >&2
        echo "Install with:" >&2
        echo "  # Ubuntu/Debian: sudo apt install fzf jq" >&2
        echo "  # macOS: brew install fzf jq" >&2
        echo "  # tn: npm install -g (or build from source)" >&2
        exit 1
    fi
}

# Format a single task for display
format_task() {
    local task="$1"
    
    # Extract fields with fallbacks
    local title=$(echo "$task" | jq -r '.title // "Untitled"')
    local task_status=$(echo "$task" | jq -r '.status // "unknown"')
    local task_priority=$(echo "$task" | jq -r '.priority // "normal"')
    local scheduled=$(echo "$task" | jq -r '.scheduled // ""')
    local due=$(echo "$task" | jq -r '.due // ""')
    local path=$(echo "$task" | jq -r '.path // ""')
    local task_id=$(echo "$task" | jq -r '.id // .path // ""')
    
    # Get tags, contexts, projects as arrays
    local tags=$(echo "$task" | jq -r 'if .tags then .tags[] else empty end' | sed 's/^/#/' | tr '\n' ' ')
    local contexts=$(echo "$task" | jq -r 'if .contexts then .contexts[] else empty end' | sed 's/^/@/' | tr '\n' ' ')
    local projects=$(echo "$task" | jq -r 'if .projects then .projects[] else empty end' | sed 's/^/+/' | tr '\n' ' ')
    
    # Color codes with safer access
    local status_color="37"
    local priority_color="37"
    
    case "$task_status" in
        "todo") status_color="37" ;;
        "open") status_color="37" ;;
        "in-progress") status_color="33" ;;
        "done") status_color="32" ;;
        "completed") status_color="32" ;;
        "cancelled") status_color="31" ;;
        "waiting") status_color="36" ;;
    esac
    
    case "$task_priority" in
        "low") priority_color="37" ;;
        "normal") priority_color="37" ;;
        "high") priority_color="35" ;;
        "urgent") priority_color="31" ;;
    esac
    
    # Status indicator
    local status_icon="○"
    case "$task_status" in
        "done"|"completed") status_icon="●" ;;
        "in-progress") status_icon="◐" ;;
        "cancelled") status_icon="✗" ;;
        "waiting") status_icon="⏸" ;;
    esac
    
    # Priority indicator  
    local priority_indicator=""
    case "$task_priority" in
        "high") priority_indicator="[HIGH]" ;;
        "urgent") priority_indicator="[URGENT]" ;;
        "low") priority_indicator="[LOW]" ;;
    esac
    
    # Date indicators
    local date_info=""
    if [[ -n "$due" ]]; then
        local due_date=$(date -d "$due" "+%m/%d" 2>/dev/null || echo "$due")
        date_info="📅$due_date"
    fi
    if [[ -n "$scheduled" ]]; then
        local sched_date=$(date -d "$scheduled" "+%m/%d" 2>/dev/null || echo "$scheduled")
        date_info="${date_info:+$date_info }⏰$sched_date"
    fi
    
    # Timer and pomodoro indicators
    local activity_info=""
    if echo "${active_timers:-}" | grep -q "^$task_id$"; then
        activity_info="⏱️"
    fi
    if [[ "${pomodoro_task:-}" == "$task_id" ]]; then
        activity_info="${activity_info:+$activity_info }🍅"
    fi
    
    # Build the line
    local line=""
    line+="\033[${status_color}m${status_icon}\033[0m "
    line+="$title"
    [[ -n "$priority_indicator" ]] && line+=" \033[${priority_color}m${priority_indicator}\033[0m"
    [[ -n "$activity_info" ]] && line+=" $activity_info"
    [[ -n "$date_info" ]] && line+=" $date_info"
    [[ -n "$tags" ]] && line+=" $tags"
    [[ -n "$contexts" ]] && line+=" $contexts" 
    [[ -n "$projects" ]] && line+=" $projects"
    line+="\t$path"  # Tab-separated path for extraction
    
    echo -e "$line"
}

# Get tasks and format for fzf
get_tasks() {
    local args=("--json" "--limit" "${limit}")
    
    # Add filter options
    [[ "$completed" == "true" ]] && args+=("--completed")
    [[ "$overdue" == "true" ]] && args+=("--overdue") 
    [[ "$today" == "true" ]] && args+=("--today")
    
    # Build compound filter from individual options
    local compound_filter=""
    [[ -n "$project" ]] && compound_filter="projects:$project"
    [[ -n "$tag" ]] && compound_filter="${compound_filter:+$compound_filter AND }tags:$tag"
    [[ -n "$filter_status" ]] && compound_filter="${compound_filter:+$compound_filter AND }status:$filter_status"
    [[ -n "$priority" ]] && compound_filter="${compound_filter:+$compound_filter AND }priority:$priority"
    
    # Combine with user-provided filter
    if [[ -n "$filter" ]]; then
        if [[ -n "$compound_filter" ]]; then
            compound_filter="($compound_filter) AND ($filter)"
        else
            compound_filter="$filter"
        fi
    fi
    
    [[ -n "$compound_filter" ]] && args+=("--filter" "$compound_filter")
    
    # Get active timer and pomodoro status
    export active_timers=$(get_active_timers)
    export pomodoro_task=$(get_pomodoro_status)
    
    # Get tasks, sort by scheduled date, format for display
    local json_output=$(tn list "${args[@]}" 2>/dev/null)
    
    if [[ -z "$json_output" ]]; then
        echo "Error: No output from tn list command" >&2
        return 1
    fi
    
    if [[ "$active_timers" == "true" ]]; then
        # Filter to show only tasks with active timers
        echo "$json_output" | jq -c '.data.tasks | sort_by(.scheduled // "9999-12-31") | .[]' | while IFS= read -r task; do
            local task_id=$(echo "$task" | jq -r '.id // .path // ""')
            if echo "${active_timers}" | grep -q "^$task_id$"; then
                format_task "$task"
            fi
        done
    else
        # Show all tasks
        echo "$json_output" | jq -c '.data.tasks | sort_by(.scheduled // "9999-12-31") | .[]' | while IFS= read -r task; do
            format_task "$task"
        done
    fi
}

# Get active timer sessions
get_active_timers() {
    tn timer status --json 2>/dev/null | jq -r '.data.activeSessions[]?.task.id // empty' 2>/dev/null || true
}

# Get current pomodoro status
get_pomodoro_status() {
    tn pomodoro status --json 2>/dev/null | jq -r 'if .data.isRunning then .data.currentSession.task.id // "no-task" else empty end' 2>/dev/null || true
}

# Note: Preview and action functions are now implemented as temporary scripts
# This avoids issues with fzf not being able to call bash functions directly

# Get vault information
get_vault_info() {
    tn list --limit 1 --json 2>/dev/null | jq -r '.data.vault // {}'
}

# Main function
main() {
    # Parse arguments
    local completed="false"
    local overdue="false"
    local today="false"
    local active_timers="false"
    local project=""
    local tag=""
    local filter_status=""
    local priority=""
    local limit="$DEFAULT_LIMIT"
    local filter=""
    local no_preview="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help)
                show_help
                exit 0
                ;;
            --completed)
                completed="true"
                shift
                ;;
            --overdue)
                overdue="true" 
                shift
                ;;
            --today)
                today="true"
                shift
                ;;
            --active-timers)
                active_timers="true"
                shift
                ;;
            --project)
                project="$2"
                shift 2
                ;;
            --tag)
                tag="$2"
                shift 2
                ;;
            --status)
                filter_status="$2"
                shift 2
                ;;
            --priority)
                priority="$2"
                shift 2
                ;;
            --limit)
                limit="$2"
                shift 2
                ;;
            --no-preview)
                no_preview="true"
                shift
                ;;
            --*)
                echo "Error: Unknown option $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
            *)
                filter="$1"
                shift
                ;;
        esac
    done
    
    # Check dependencies
    check_dependencies
    
    # Get vault information
    echo "Getting vault information..." >&2
    local vault_info=$(get_vault_info)
    local vault_name=$(echo "$vault_info" | jq -r '.name // "unknown"')
    local vault_path=$(echo "$vault_info" | jq -r '.path // ""')
    
    if [[ -z "$vault_path" || "$vault_path" == "null" ]]; then
        echo "Error: Could not get vault path from TaskNotes API" >&2
        exit 1
    fi
    
    echo "Vault: $vault_name ($vault_path)" >&2
    echo "Loading tasks..." >&2
    
    # Create temporary script for preview
    local preview_script="/tmp/tn-fzf-preview-$$"
    cat > "$preview_script" << EOF
#!/bin/bash
line="\$1"
vault_path="$vault_path"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
full_path="\$vault_path/\$path"

if [[ -f "\$full_path" ]]; then
    echo "📄 \$path"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo
    if command -v bat >/dev/null; then
        bat --style=plain --color=always --language=markdown "\$full_path" 2>/dev/null || cat "\$full_path"
    elif command -v highlight >/dev/null; then
        highlight -O ansi --syntax=markdown "\$full_path" 2>/dev/null || cat "\$full_path"
    else
        cat "\$full_path"
    fi
else
    echo "❌ File not found: \$full_path"
fi
EOF
    chmod +x "$preview_script"
    
    # Create temporary script for editor
    local editor_script="/tmp/tn-fzf-editor-$$"
    cat > "$editor_script" << EOF
#!/bin/bash
line="\$1"
vault_path="$vault_path"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
full_path="\$vault_path/\$path"
editor="\${EDITOR:-nano}"

if [[ -f "\$full_path" ]]; then
    echo "Opening \$path in \$editor..."
    "\$editor" "\$full_path"
else
    echo "Error: File not found: \$full_path"
    read -p "Press any key to continue..."
fi
EOF
    chmod +x "$editor_script"
    
    # Create temporary script for reload
    local reload_script="/tmp/tn-fzf-reload-$$"
    cat > "$reload_script" << EOF
#!/bin/bash
cd "$PWD"
export completed="$completed" overdue="$overdue" today="$today" limit="$limit" filter="$filter"
source "./bin/tn-fzf"
get_tasks 2>/dev/null
EOF
    chmod +x "$reload_script"
    
    # Create temporary script for adding new task
    local add_task_script="/tmp/tn-fzf-add-$$"
    cat > "$add_task_script" << EOF
#!/bin/bash
cd "$PWD"
echo "Creating new task..."
echo "Press Ctrl-C to cancel and return to task list"
echo
node bin/tn
EOF
    chmod +x "$add_task_script"
    
    # Create temporary script for task completion/toggle
    local toggle_script="/tmp/tn-fzf-toggle-$$"
    cat > "$toggle_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
echo "Toggling task status: \$path"
node bin/tn toggle "\$path"
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$toggle_script"
    
    # Create temporary script for task deletion
    local delete_script="/tmp/tn-fzf-delete-$$"
    cat > "$delete_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
task_title=\$(echo "\$line" | cut -d\$'\t' -f1 | sed 's/[^[:print:]]//g' | sed 's/\[.*\]//g' | sed 's/[📅⏰🍅⏱️●◐○✗⏸]//g' | xargs)
echo "Delete task: \$task_title"
echo "File: \$path"
echo 
read -p "Are you sure? (y/N): " confirm
if [[ "\$confirm" =~ ^[Yy]$ ]]; then
    node bin/tn delete "\$path" --force
    echo "Task deleted."
else
    echo "Cancelled."
fi
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$delete_script"
    
    # Create temporary script for task updates
    local update_script="/tmp/tn-fzf-update-$$"
    cat > "$update_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
task_title=\$(echo "\$line" | cut -d\$'\t' -f1 | sed 's/[^[:print:]]//g' | sed 's/\[.*\]//g' | sed 's/[📅⏰🍅⏱️●◐○✗⏸]//g' | xargs)

echo "Update task: \$task_title"
echo "File: \$path"
echo
echo "Available updates:"
echo "1) Status    2) Priority    3) Due date    4) Title"
echo "5) Add tags  6) Add project 7) Time estimate"
echo
read -p "Choose option (1-7): " choice

case \$choice in
    1) 
        echo "Status options: todo, open, in-progress, completed, cancelled, waiting"
        read -p "New status: " status
        [[ -n "\$status" ]] && node bin/tn update "\$path" --status "\$status"
        ;;
    2)
        echo "Priority options: low, normal, high, urgent"
        read -p "New priority: " priority
        [[ -n "\$priority" ]] && node bin/tn update "\$path" --priority "\$priority"
        ;;
    3)
        read -p "Due date (YYYY-MM-DD or natural language): " due
        [[ -n "\$due" ]] && node bin/tn update "\$path" --due "\$due"
        ;;
    4)
        read -p "New title: " title
        [[ -n "\$title" ]] && node bin/tn update "\$path" --title "\$title"
        ;;
    5)
        read -p "Tags to add (comma-separated): " tags
        [[ -n "\$tags" ]] && node bin/tn update "\$path" --add-tags "\$tags"
        ;;
    6)
        read -p "Project to add: " project
        [[ -n "\$project" ]] && node bin/tn update "\$path" --add-projects "\$project"
        ;;
    7)
        read -p "Time estimate (minutes): " estimate
        [[ -n "\$estimate" ]] && node bin/tn update "\$path" --estimate "\$estimate"
        ;;
    *)
        echo "Invalid option"
        ;;
esac
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$update_script"
    
    # Create temporary script for starting timer
    local start_timer_script="/tmp/tn-fzf-start-timer-$$"
    cat > "$start_timer_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
task_title=\$(echo "\$line" | cut -d\$'\t' -f1 | sed 's/[^[:print:]]//g' | sed 's/\[.*\]//g' | sed 's/[📅⏰🍅⏱️●◐○✗⏸]//g' | xargs)
echo "Starting timer for: \$task_title"
node bin/tn timer start --task "\$path"
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$start_timer_script"
    
    # Create temporary script for stopping timer
    local stop_timer_script="/tmp/tn-fzf-stop-timer-$$"
    cat > "$stop_timer_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
task_title=\$(echo "\$line" | cut -d\$'\t' -f1 | sed 's/[^[:print:]]//g' | sed 's/\[.*\]//g' | sed 's/[📅⏰🍅⏱️●◐○✗⏸]//g' | xargs)
echo "Stopping timer for: \$task_title"
node bin/tn timer stop --task "\$path"
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$stop_timer_script"
    
    # Create temporary script for starting pomodoro
    local start_pomodoro_script="/tmp/tn-fzf-pomodoro-$$"
    cat > "$start_pomodoro_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
task_title=\$(echo "\$line" | cut -d\$'\t' -f1 | sed 's/[^[:print:]]//g' | sed 's/\[.*\]//g' | sed 's/[📅⏰🍅⏱️●◐○✗⏸]//g' | xargs)
echo "Starting pomodoro for: \$task_title"
echo
echo "Durations: 1) 25min (default)  2) 15min  3) 45min  4) Custom"
read -p "Choose (1-4): " choice
case \$choice in
    2) duration="15" ;;
    3) duration="45" ;;
    4) read -p "Duration in minutes: " duration ;;
    *) duration="" ;;
esac

if [[ -n "\$duration" ]]; then
    node bin/tn pomodoro start --task "\$path" --duration "\$duration"
else
    node bin/tn pomodoro start --task "\$path"
fi
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$start_pomodoro_script"
    
    # Create temporary script for task details
    local details_script="/tmp/tn-fzf-details-$$"
    cat > "$details_script" << EOF
#!/bin/bash
line="\$1"
cd "$PWD"
path=\$(echo "\$line" | cut -d\$'\t' -f2)
task_title=\$(echo "\$line" | cut -d\$'\t' -f1 | sed 's/[^[:print:]]//g' | sed 's/\[.*\]//g' | sed 's/[📅⏰🍅⏱️●◐○✗⏸]//g' | xargs)

echo "Task Details: \$task_title"
echo "════════════════════════════════════════"

# Get detailed task info
echo "📋 Task Information:"
node bin/tn list --filter "path:\$path" --json | jq -r '.data.tasks[0] | 
  "ID: " + (.id // "N/A") + "\n" +
  "Status: " + (.status // "N/A") + "\n" +
  "Priority: " + (.priority // "N/A") + "\n" +
  "Due: " + (.due // "Not set") + "\n" +  
  "Scheduled: " + (.scheduled // "Not set") + "\n" +
  "Tags: " + (if .tags then (.tags | join(", ")) else "None" end) + "\n" +
  "Contexts: " + (if .contexts then (.contexts | join(", ")) else "None" end) + "\n" +
  "Projects: " + (if .projects then (.projects | join(", ")) else "None" end) + "\n" +
  "Time Estimate: " + (if .timeEstimate then (.timeEstimate | tostring) + " minutes" else "Not set" end)'

echo
echo "⏱️ Time Tracking:"
node bin/tn timer log --task "\$path" 2>/dev/null | tail -n +3 || echo "No time tracking data"

echo
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$details_script"
    
    # Create temporary script for timer status
    local timer_status_script="/tmp/tn-fzf-timer-status-$$"
    cat > "$timer_status_script" << EOF
#!/bin/bash
cd "$PWD"
echo "Current Timer Status:"
echo "═══════════════════════"
node bin/tn timer status
echo
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$timer_status_script"
    
    # Create temporary script for pomodoro status
    local pomodoro_status_script="/tmp/tn-fzf-pomodoro-status-$$"
    cat > "$pomodoro_status_script" << EOF
#!/bin/bash
cd "$PWD"
echo "Current Pomodoro Status:"
echo "══════════════════════"
node bin/tn pomodoro status
echo
echo "Press any key to continue..."
read -n 1
EOF
    chmod +x "$pomodoro_status_script"

    # Set up fzf options
    local fzf_opts=(
        "--ansi"
        "--height=$FZF_HEIGHT"
        "--layout=reverse"
        "--border"
        "--info=inline"
        "--prompt=Tasks❯ "
        "--header=ENTER=Obsidian | Alt-C=Toggle | Alt-T=Timer | Alt-P=Pomodoro | Alt-I=Details | Ctrl-R=Refresh"
        "--bind=ctrl-r:reload($reload_script)"
        "--bind=ctrl-e:execute($editor_script {})"
        "--bind=alt-a:execute($add_task_script)+reload($reload_script)"
        "--bind=alt-c:execute($toggle_script {})+reload($reload_script)"
        "--bind=alt-d:execute($delete_script {})+reload($reload_script)"
        "--bind=alt-u:execute($update_script {})+reload($reload_script)"
        "--bind=alt-t:execute($start_timer_script {})"
        "--bind=alt-s:execute($stop_timer_script {})"
        "--bind=alt-p:execute($start_pomodoro_script {})"
        "--bind=alt-i:execute($details_script {})"
        "--bind=ctrl-t:execute($timer_status_script)"
        "--bind=ctrl-p:execute($pomodoro_status_script)"
        "--delimiter=\t"
        "--with-nth=1"
    )
    
    # Add preview if not disabled
    if [[ "$no_preview" != "true" ]]; then
        fzf_opts+=(
            "--preview=$preview_script {}"
            "--preview-window=right:$PREVIEW_WIDTH:wrap"
        )
    fi
    
    # Run fzf and handle result
    local selected
    selected=$(get_tasks | fzf "${fzf_opts[@]}")
    
    # Cleanup temporary scripts
    rm -f "$preview_script" "$editor_script" "$reload_script" "$add_task_script" \
          "$toggle_script" "$delete_script" "$update_script" "$start_timer_script" \
          "$stop_timer_script" "$start_pomodoro_script" "$details_script" \
          "$timer_status_script" "$pomodoro_status_script"
    
    # Handle selection (ENTER key - open in Obsidian)
    if [[ -n "$selected" ]]; then
        local path=$(echo "$selected" | cut -d$'\t' -f2)
        local file_path=$(echo "$path" | sed 's/\.md$//')  # Remove .md extension for Obsidian
        
        # Create Obsidian URL
        local obsidian_url="obsidian://open?vault=$(printf '%s' "$vault_name" | jq -rR @uri)&file=$(printf '%s' "$file_path" | jq -rR @uri)"
        
        echo "Opening in Obsidian: $file_path"
        
        # Open with appropriate command based on OS
        if command -v xdg-open >/dev/null; then
            xdg-open "$obsidian_url" >/dev/null 2>&1
        elif command -v open >/dev/null; then
            open "$obsidian_url" >/dev/null 2>&1  
        else
            echo "Error: Could not open Obsidian URL. Install xdg-open (Linux) or use macOS."
            echo "URL: $obsidian_url"
        fi
    fi
}

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]:-$0}" == "${0}" ]]; then
    main "$@"
fi